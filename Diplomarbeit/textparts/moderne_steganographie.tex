\chapter{Moderne Steganographie}
	
	Mit moderner Steganographie sind Verfahren gemeint, welche nur mit Hilfsmittel der elektronischen Datenverarbeitung funktionieren. Sie verlassen sich meist darauf das in riesigen Zahlenmengen kleine Hinweise versteckt sind. Solch große Datenmengen lassen sich per Hand nicht mehr berechnen, wie etwa die vielen Millionen Bildpunkte auf einer digital Fotografie. 
	
	In dem nachfolgendem Kapitel werden einige dieser Verfahren erklärt und etwaige Fehler und Schwierigkeiten die damit verbunden sind aufgezeigt. Außerdem werden einige Implementierungen gezeigt, verglichen und auf die Verwendbarkeit im Alltag getestet. 
	
	\section{Allgemein}
	
	\subsection{Whitening}
	
	
	Als Whitening werden Prozesse und Techniken bezeichnet mit dem Ziel, Daten jegliche Ordnung und Regelmäßigkeit zu entziehen. Je besser ein Whitening Verharen funktioniert desto weniger ist der Datenstrom von generierten Zufallswerten unterscheidbar. \\
	
	Dies hat den Vorteil, dass die Daten nach der Transformation in dem einzubettendem Medium nicht so stark auffallen wie zuvor. \\
	
	Whitening Verfahren wandeln auf deterministische Weise Datenströme, welche in etwa wie \ref{fig:L: Whitening Clear} aussehen können, um damit sie dem Profil von \ref{fig:L: Whitening Random} ähneln. Dies muss auf eine Art und Weise geschehen das beim extrahieren der Daten die angewandte Operation wieder rückgängig gemacht werden kann. Es können also keine wirklich zufälligen Techniken zum Einsatz kommen. Man verwendet hier vor allem sogenannte Pseudozufallsgeneratoren, welche lediglich die Eigenschaften von echten zufälligen Ereignissen nachahmen, bei Bedarf aber beliebig oft wiederholt werden können. Dadurch ist sichergestellt das sich die angewandten Operationen auch wieder rückgängig machen lassen. Es werden auch oft Methoden aus der Kryptologie verwendet, welche nicht nur herausragende Ergebnisse in Hinsicht auf Zufälligkeit erzielen, sondern zugleich auch die Daten mit Hilfe eines Keys schützen.
	 
	
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=1]{images/L-whitening-clear.png}
		\caption{Hier deutlich zu erkennen die verwendeten ASCII Zeichen.}
		\label{fig:L: Whitening Clear}
	\end{figure}

	\begin{figure}[H]
		\centering
		\includegraphics[scale=1]{images/L-whitening-random.png}
		\caption{In diesen zufälligen Daten kann kein Muster erkannt werden.}
		\label{fig:L: Whitening Random}
	\end{figure}
	
	\ltodo{Höhere Auflösung für Whitening Diagramme https://docs.google.com/spreadsheets/d/1xDMWNJa9r2ggmzPAmDgE8qYJ5hk-8Hh9ZFuKrGrx7Gw}
	
	
	
	
     
	
	\subsubsection {Pseudozufallsgenerator mit bitweiser Verknüpfung}
	
	Bei Verfahren welche auf Pseudozufallsgeneratoren bauen ist die größte Stärke auch gleich die größte Schwäche: ''Sie sind vorhersehbar''. Sie Schützen zwar das Steganogramm vor unwissenden Dritten, wie so oft aber nicht wenn jemand gezielt danach sucht. Ihre sehr beschränkte Anzahl an Seeds und die Reproduzierbarkeit führen dazu das ein Angreifer sehr einfach auf die gängigsten Generatoren testen kann. 
	\\
	Das hier zur Anwendung kommende Prinzip ''Security through obscurity'' war bereits zu Beginn des 20. Jahrhunderts bekannt und auch als nicht sicher eingestuft. Das bekannteste Beispiel für Security through obscurity ist einen nicht standardisierten Port für eine Webanwendung zu verwenden. Dies Schützt zwar vor automatisierten Bots, ein gezielter Angriff hebelt diesen ''Sicherheitsmechanismus'' innerhalb von Minuten aus. Genau so ist es mit schwachen Whitening Verfahren welche auf Obskurität setzen.
	\\
	In dem nachfolgenden Beispiel wird als Whitening der Datenstrom mit Hilfe der XOR-Operation mit einem Pseudozufallszahlengeneratoren Datenstrom verknüpft. Zum Einsatz kommt hier ein Kongruenzgenerator wie er auch in der Standard Java Klasse java.lang.Random verwendet wird.  
	
	\begin{figure}[H]
	\begin{tabular}{|l|l|c|c|c|c|c|c|}
		\hline 
		& Byte 1 & Byte 2 & Byte 3 & Byte 4 & Byte 5 & Byte 6 \\ 
		\hline 
		Inhalt  & L & o & r & e & m &   \\ 
		\hline 
		Datenstrom & 76 & 111 & 114 & 101 & 109 & 32 \\ 
		\hline 
		Random (Seed=0) & 187 & 212 & 61 & 155 & 163 & 79 \\ 
		\hline 
		Datenstrom XOR Random & 247 & 187 & 79 & 254 & 206 & 111 \\ 
		\hline 
	\end{tabular} 	
    \caption{Wenn der Inhalt wieder hergestellt werden soll muss nur von unten nach oben alles wieder Rückgängig gemacht werden.}
	\label{fig:L: Whitening Random Tabelle}
\end{figure}
	
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=1]{images/L-whitening-vergleich.png}
		\caption{In diesem Vergleich ist gut zu sehen das nach Anwendung von diesem Verfahren der Datenstrom nicht mehr von zufälligen Werten unterscheidbar ist.}
		\label{fig:L: Whitening Random}
	\end{figure}
	
	\subsubsection {AES-256 Verschlüsselung mit Key}
	
	Es kann auch die Eigenschaft von Verschlüsselung genutzt werden, Daten derart zu verarbeiten dass sie nicht mehr von zufälligen Werten unterscheidbar ist. In dem nachfolgenden Beispiel wird die zurzeit als sicher geltende AES-256 Verschlüsselung verwendet. 
	
	Folgende Java Funktion wurde für die Verschlüsselung des Plaintext verwendet:
	\lstinputlisting[firstline=30,lastline=42,caption={AESVerfahren.java},label={fig:L: AES Java}]{sources/AESVerfahren.java}
	
	Wenn man die daraus resultierenden Daten auswertet, lässt sich wieder der gewünschte Whitening-Effekt beobachten. 
	\begin{figure}[H]
		\centering
		\includegraphics[scale=1]{images/L-whitening-aes.png}
		\caption{Vergleich zwischen AES verschlüsselten Daten und zufälligen Werten.}
		\label{fig:L: Whitening AES}
	\end{figure}

	
	\subsection{Fehlerkorrekturverfahren}
	
	Moderne Verfahren sind sehr anfällig auf verlustbehaftete Komprimierung. Dadurch das sie meistens darauf basieren einzelne Bits zu verändern, passiert es auch sehr schnell das die erneute Manipulation des Trägermaterials zum Verlust der versteckten Daten führt. In dem folgenden Abschnitt werden Techniken vorgestellt um diesen Informationsverlust zu verhindern oder wenigstens zu entdecken. Des weiteren werden mehrere Verfahren nach Robustheit verglichen.
	
	\subsubsection{Redundante Datenspeicherung}
	
	Eine Möglichkeit ist es die Daten mehrfach abzuspeichern. Das bietet Schutz vor Manipulation von einzelnen Teilen des Bild. Zum Beispiel das Wegschneiden von Rändern, das Entfernen von Gesichtern, Wasserzeichen oder einfach Bild Über- und Unterschriften welche erst später zu dem Bild hinzugefügt werden.  
	
	Keine Verbesserung der Robustheit findet jedoch bei Komprimierung des Trägermaterial statt, denn hier werden alle Teile geringfügig verändert was bereits ausreicht um einen kompletten Informationsverlust zu verursachen. 
	
	Auch wenn das Trägermaterial vergrößert/verkleinert wird Hilft redundante Speicherung meist nicht. Bei Skalierung von Bildern werden immer Filtering Methoden eingesetzt werden. Diese kombinieren oft mehrere Pixel zu einem einzelnen und wenden dabei zahlreiche Operationen an. Dadurch geht fast immer sämtliche steganographisch versteckte Information verloren. 
	
	\subsubsection{Paritätsbit}
	
	Die Parität einer Zahl beschreibt ob eine Zahl durch zwei Teilbar ist. Das Paritätsbit wird zur Überprüfung auf Übertragungsfehler verwendet indem es nach einer festgelegten Anzahl an übertragenen Bits mitgesendet wird. Es werden die gesetzten Bits des zu überprüfenden Bereich gezählt. Ist dieser Wert nun eine gerade/ungerade Zahl wird das Paritätsbit entsprechend gesetzt.

	Wenn im Laufe der Übertragung ein einzelnes Bit umgedreht wird kann dies durch das Paritätsbit entdeckt werden. Der Fehler selbst kann dadurch aber nicht ausgebessert werden, da nicht bekannt ist wo er in der Bitfolge aufgetreten ist. Außerdem kann nur eine ungerade Anzahl an Fehlern festgestellt werden. Eine Weiterentwicklung diese Verfahren stellt der unten vorgestellte Hamming-Code dar.
	
	\subsubsection{Zyklische Redundanzprüfung (\zb CRC-32)}
	
	Die zyklische Redundanzprüfung basiert auf Polynomdivison. Es wird ein CRC-Polynom gewählt welches dessen Koeffizienten entweder 1 oder 0 sind. So entspricht etwa die Bitfolge 110101 dem Polynom $ x^{5} + x^{4} + x^{2} + 1$
	
	\subsubsection{Hamming-Code}
	
	\section{Verstecken von Dateien}
	% https://de.wikibooks.org/wiki/Disk-Forensik/\_Sicherstellung/\_Versteckte\_Daten\#Alternate\_Data\_Streams\_.28ADS.29
	% http://www.tippscout.de/kommandozeile-log-dateien-kombinieren_tipp_3644.html
	
	\ltodo{Ist das wirklich Steganographie?}
	Die Dateisysteme der Betriebssysteme bieten zahlreiche Möglichkeiten um seine Daten für dritte schwer auffindbar zu machen. In der folgenden Tabelle werden einige Verfahren verglichen und anschließend genauer erläutert. Es ist jedoch zu Bemerken, dass es sich hier um sehr einfache Verfahren handelt die höchstens Schutz gegen Computeranfänger bietet und für jeden Forensiker keine Herausforderung darstellen.
	
	\begin{tabular}{|l|l|l|l|}
		\hline 
		Beschreibung & Anwendbarkeit & Human Attack & Computer Attack \\ 
		\hline 
		Alternativer Datenstream & ext. Programm wird benötigt & mittel & einfach \\ 
		\hline 
		Dateien Verketten & überall unterstützt & mittel & einfach \\
		\hline
		Versteckte Datei & überall unterstützt & einfach & einfach \\
		\hline
		Dateiendung verändern & nur auf windows und osx \footnote{Linux verwendet das Programm ''file'' um über die Magic Number den Dateityp zu erkennen} & einfach & sehr einfach \\
		\hline
	\end{tabular} 

	\subsection{Alternativer Datenstream}
	% https://www.irongeek.com/i.php?page=security/altds
	
	Die alternativen Dateistreams wurden von Windows bei ihrem Dateisystem NTFS deshalb eingefügt, da sie auch das Dateisystem von Apple HFS unterstützen wollten. Dort werden sogenannte Resource Forks verwendet um weitere Informationen wie Icons für Dateien zu speichern. Diese Dateistreams sind mit dem normalen Datei Explorer von Windows nicht direkt sichtbar, können aber erahnt werden wenn man die in den Eigenschaften angezeigte Größe mit der tatsächlichen Größe vergleicht. Vor allem für große versteckte Dateien wie Bilder oder Videos können hier leicht große Unterschiede erkannt werden.	
	
	
	\subsubsection{Erstellen von ADS unter Windows}

	Alternative Dateistreams können nicht einfach mit dem Windows Explorer erstellt werden. Die einfachste Möglichkeit unter Windows alternative Dateistreams zu erstellen ist über die Kommandozeile. Angesprochen werden die einzelnen Streams über den Dateinamen der sichtbaren Trägerdatei und einem mit Doppelpunkt getrennten Namen für den Stream. Über diesen Bezeichner kann nun jedes Programm auf den alternativen Stream zugreifen.
	
	Als Trägerdatei kann jede beliebige Datei verwendet werden. Je größer die gewählte Trägerdatei ist, desto unwahrscheinlicher ist es das jemanden der zusätzliche Datenstream auffällt. In dem folgenden Beispiel wird die Datei ''unscheinbare\_textdatei.txt'' über die Windows-Kommandozeile erstellt und mit einem unbedeutenden Text befüllt.
	\begin{lstlisting}
	echo "Hallo Welt, hier ist nichts." > unscheinbare_textdatei.txt
	\end{lstlisting}
	
	Nun kann man mit dem gleichen Befehl und einem angepassten Dateinamen auf gleiche Weise alternative Datenstreams befüllen.
	\begin{lstlisting}
	echo "Geheim" > unscheinbare_textdatei.txt:geheimer_stream.txt
	\end{lstlisting}
	
	Sowohl die Trägerdatei als auch der alternative Stream können mit jedem beliebigen Programm jederzeit bearbeitet werden. Zu beachten ist nur wieder das der Explorer und alle ''Datei öffnen'' Dialoge die geheimen Streams nicht anzeigt. Dazu muss man wieder auf die Kommandozeile zurückgreifen. Zum Beispiel kann man den Stream mit dem Programm Notepad von Windows öffnen.
	\begin{lstlisting}
	notepad unscheinbare_textdatei.txt:geheimer_stream.txt
	\end{lstlisting}
	
	Wie man sehen kann können diese alternativen Streams von jedem Programm ohne viel Mehraufwand geöffnet werden. Sie stellen also keinen ausreichenden Schutz vor ungewollten Zugriff auf den Inhalt da.\\
	Um sich eine Übersicht über alle Dateien und ihre Streams machen zu können gibt es zahlreiche fertige Tools, welche ohne viel Aufwand das gesamte Dateisystem nach solchen Strukturen durchsuchen. Bei einem konkreten Verdacht kann jedoch auch das bei Windows mitgelieferte Programm $dir$ verwendet werden.
	Man navigiert über die Kommandozeile in den jeweiligen Ordner und dort ruft man den $dir$ Befehl mit dem Parameter $/r$ auf.
	
	\begin{lstlisting}
	C:\stuff>dir /r
	Datenträger in Laufwerk C: ist Windows
	Volumeseriennummer: F8D1-CAC1
	
	Verzeichnis von C:\stuff
	
	16.02.2017  17:37    <DIR>     .
	16.02.2017  17:37    <DIR>     ..
	16.02.2017  17:44           28 unscheinbare_textdatei.txt
	                            11 unscheinbare_textdatei.txt:geheimer_stream.txt:$DATA
	\end{lstlisting}
	
	\subsection{Dateien Verketten}
	
	Viele Dateiformate besitzen eine interne Angabe über wie lang die Datei sein sollte. Dies kann ausgenützt werden indem man eine Payload am Ende der Datei anfügt. Programme welche die Trägerdatei lesen wollen ignorieren den zusätzlich angehängten Teil. Die versteckte Datei kann schnell und einfach wieder aus der Trägerdatei extrahiert werden. \\
	
	Zu beachten ist hier vor allem das man eine geeignete Trägerdatei wählt. Denn bei einer Datei welche sich oft in der Länge ändert kann es passieren das sein Versteckter angehängter Teil einfach überschrieben wird. Außerdem sollte darauf geachtet werden dass die Datei eine fix definierte Länge besitzt. Eine Beispiel für geeignete Dateiformate sind Bild- und Videoformate, sofern man sie nicht noch weiter bearbeiten will. Diese besitzen eine im Header der Datei angegebene Länge und haben auch eine relativ große Größe, wodurch kleinere angehängte Dateien im Speicherplatzverbrauch nicht so stark auffallen. 
	
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.8]{images/L-bmp.png}
		\caption{Beispiel für das Verstecken einer Datei am Ende einer Bitmap}
		\label{fig:L: Datei in Bitmap}
	\end{figure}
	% http://paulbourke.net/dataformats/bmp/
	
	\section{Modifikation von Bilddateien} \ltodo{Die ganze Sache gibt es auch in der klassischen wo es darum geht z.B. in der Länge der Gartenzaunbretter Informationen zu verstecken}
	
	Bilder auf einem Computer sind nichts anderes als Matrizen welche Farbeinformationen für die einzelnen Pixel des Bildes beinhalten. Es gibt zahlreiche Verfahren in diesen Daten zu verstecken. Im den folgenden Kapitel werden einige dieser Verfahren vorgestellt. Dadurch dass alle Daten im Computer in Binärform als Zahl gespeichert sind, ist es vollkommen egal welche Datei als Payload eingebettet wird. 
	
	Aus diesem Grund wird in den Beispielen die Kodierung aus \ref{L: Kodierung Payload} für die Payload verwendet.
	\begin{table}[]
		\centering
		\caption{Kodierungstabelle der Payload}
		\label{L: Kodierung Payload}
		\begin{tabular}{|lll|lll|lll|lll|}
			\hline
			\textbf{Zeichen} & \textbf{DEC} & \textbf{BIN} & \textbf{Zeichen} & \textbf{DEC} & \textbf{BIN} & \textbf{Zeichen} & \textbf{DEC} & \textbf{BIN} & \textbf{Zeichen} & \textbf{DEC} & \textbf{BIN} \\ \hline
			A                & 0            & 000000        & I                & 8            & 001000        & Q                & 16           & 010000        & Y                & 24           & 011000        \\
			B                & 1            & 000001        & J                & 9            & 001001        & R                & 17           & 010001        & Z                & 25           & 011001        \\
			C                & 2            & 000010        & K                & 10           & 001010        & S                & 18           & 010010        & Leerzeichen      & 26           & 011010        \\
			D                & 3            & 000011        & L                & 11           & 001011        & T                & 19           & 010011        & .                & 27           & 011011        \\
			E                & 4            & 000100        & M                & 12           & 001100        & U                & 20           & 010100        & ,                & 28           & 011100        \\
			F                & 5            & 000101        & N                & 13           & 001101        & V                & 21           & 010101        & ?                & 29           & 011101        \\
			G                & 6            & 000110        & O                & 14           & 001110        & W                & 22           & 010110        & !                & 30           & 011110        \\
			H                & 7            & 000111        & P                & 15           & 001111        & X                & 23           & 010111        & ''               & 31           & 011111        \\
			\hline
		\end{tabular}
	\end{table}
%	\begin{table}[]
%		\centering
%		\caption{Kodierungstabelle der Payload}
%		\label{L: Kodierung Payload}
%		\begin{tabular}{|lll|lll|lll|lll|}
%			\hline
%			\textbf{Zeichen} & \textbf{DEC} & \textbf{BIN} & \textbf{Zeichen} & \textbf{DEC} & \textbf{BIN} & \textbf{Zeichen} & \textbf{DEC} & \textbf{BIN} & \textbf{Zeichen} & \textbf{DEC} & \textbf{BIN} \\ \hline
%			A                & 32            & 100000        & I                & 40           & 101000        & Q                & 48           & 110000        & Y                & 56           & 111000        \\
%			B                & 33            & 100001        & J                & 41           & 101001        & R                & 49           & 110001        & Z                & 57           & 111001        \\
%			C                & 34            & 100010        & K                & 42           & 101010        & S                & 50           & 110010        & Zeilenumbruch    & 58           & 111010        \\
%			D                & 35            & 100011        & L                & 43           & 101011        & T                & 51           & 110011        & >                & 59           & 111011        \\
%			E                & 36            & 100100        & M                & 44           & 101100        & U                & 52           & 110100        & <                & 60           & 111100        \\
%			F                & 37            & 100101        & N                & 45           & 101101        & V                & 53           & 110101        & (                & 61           & 111101        \\
%			G                & 38            & 100110        & O                & 46           & 101110        & W                & 54           & 110110        & )                & 62           & 111110        \\
%			H                & 39            & 100111        & P                & 47           & 101111        & X                & 55           & 110111        & End of Message   & 63           & 111111        \\
%			\hline
%		\end{tabular}
%	\end{table}
	
	
	\subsection{LSB Verfahren}
	
	Das Least Significant Bit Verfahren nützt die Tatsache aus, dass der Farbraum einer modernen Bilddatei sehr groß ist\footnote{Bei den meisten Formaten 24-Bit, wodurch 16,777,216 Farben dargestellt werden können}. Dadurch ist es für das menschliche Auge sehr schwierig, eng beieinander liegende Farbtöne zu unterscheiden. Computerprogramme können nun gezielt einzelne Farben manipulieren um Informationen in den Pixel des Bildes zu kodieren. 
	
	Bei einem 24-Bit RGB Bild besteht jeder Farbkanal aus 8 Bit. Um die Nachricht zu kodieren wird das LSB von einem oder mehreren der Farbkanäle des Pixel auf den jeweiligen Wert aus der kodierten Nachricht gesetzt. Da das LSB nur einen wertmäßigen Unterschied von +-1 ausmacht wenn es verändert wird, fällt diese Änderung kaum auf. Wenn wir bei einem Pixel einen der Farbkanäle bearbeiten verändern wir den Farbwert des Kanal um $\frac{1}{256} = 0.39\% $. Der Farbwert des Pixel ändert sich sogar nur um $ \frac{1}{16777216} = 0.00000596\% $. Es ist so gut wie unmöglich mit dem freien Auge hier noch einen Unterschied zu erkennen.
	
	Ein große Rolle spielt wie viel Trägermaterial zur Verfügung steht und wie viele Daten darin eingebettet werden. Je nachdem kann man die einzelnen Bits weiter verteilen oder muss sogar mehrere Bits auf ein Pixel. 
	Es ist auch durchaus sinnvoll diverse Prüfsummen in die eingebetteten Daten einzubauen um sicher zu stellen das die extrahierten Daten auch keine Fehler enthalten. Wenn genug Platz zur Verfügung steht ist es auch möglich die Daten redundant zu speichern.
	
	\ltodo{Tabelle mit Vergleich wie viele Bit Farbe / wie viele Bit Daten und wie viel Prozent das ausmacht + Bildbeispiele für den Farbunterschied den das ausmacht}
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.8]{images/L-lsb-entwurf.png}
		\caption{LSB Entwurf, muss ich noch verbessern..}
		\label{fig:L: LSB in Bitmap}
	\end{figure}
	
	In dem Beispiel aus \ref{fig:L: LSB Tabelle} wurde eine Datendichte von einem Zeichen pro Pixel gewählt. Bei einem Bild mit 2  Megapixel lassen sich bis zu 2 Millionen Zeichen abspeichern. Das Buch ''Schöne neue Welt'' von Aldous Huxley hat rund 430.000 Zeichen, geht sich also bereits vier Mal in einem doch recht kleinen Bild aus. Das setzt aber Voraus das die in \ref{L: Kodierung Payload} angeführte Kodierungstabelle verwendet wird. Diese unterstützt aber weder Kleinbuchstaben noch Zeilenumbrüche, Umlaute oder Zahlen. Das Buch wäre durchaus noch lesbar, aber eben doch recht umständlich. In der ASCII Kodierung hat das Buch eine Größe von 449.414 Bytes, also 3.595.312 Bits. Bei einer Datendichte von 6 Bit / Pixel geht sich das Buch dennoch in einem 2 Megapixel großen Bild aus.
	
	\begin{figure}[H]
		\centering
		\begin{tabular}{|c|c|c|c|c|c|c|c|}
			\hline 
			Pixel Nummer & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\ 
			\hline 
			Nachricht & T & R & E & F & F & P & U \\ 
			\hline 
			Dec & 19 & 17 & 4 & 4 & 5 & 15 & 20 \\ 
			\hline 
			Binär & 10011 & 10001 & 00100 & 00100 & 00101 & 01111 & 10100 \\ 
			\hline 
			Roter Farbwert & RRRR RR10 & RRRR RR10 & RRRR RR00 & RRRR RR00 & RRRR RR00 & RRRR RR01 & RRRR RR10 \\ 
			\hline 
			Grüner Farbwert & GGGG GG01 & GGGG GG00 & GGGG GG10 & GGGG GG10 & GGGG GG10 & GGGG GG11 & GGGG GG10 \\ 
			\hline 
			Blauer Farbwert & BBBB BBB1 & BBBB BBB1 & BBBB BBB0 & BBBB BBB0 & BBBB BBB1 & BBBB BBB1 & BBBB BBB0 \\ 
			\hline 
		\end{tabular} 
		\caption{Beispiel für 1 Zeichen pro Pixel.}
		\label{fig:L: LSB Tabelle}
	\end{figure}
	
	In dem in \ref{fig:L: LSB Earth} gezeigtem Beispiel wurde das Buch ''Schöne neue Welt'' in ein Bild der Erde integriert. Verwendet wurde das in \ref{fig:L: LSB Java} gezeigte Java-Programm. Die kurze Länge des Programm zeigt das dieses Verfahren sehr einfach zu implementieren ist. Man kann durchaus, egal wo man sich gerade befindet, mit Hilfe eines Computers ein Programm schreiben und geheime Nachrichten versenden. Durch den  zusätzlichen Einsatz von Whitening kann also von überall aus eine Steganografisch sichere Datenübermittlung stattfinden, ohne weitere Tools. 
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.3]{images/L-schoene-neue-earth.png}
		\caption{In diesem Bild wurde ein ganzes Buch versteckt, und es ist trotzdem nicht zu erkennen.}
		\label{fig:L: LSB Earth}
	\end{figure}

	\lstinputlisting[caption={LSBVerfahren.java},label={fig:L: LSB Java}]{sources/LSBVerfahren.java}

	
	Wenn die einzubettenden Daten nicht den gesamten Verfügbaren ''Speicherplatz'' innerhalb des Steganogramm verwenden, sollte unbedingt ein Padding aus zufälligen Daten hinzugefügt werden. Sonst können sich deutliche Unterschiede in dem Aussehen des Bild ergeben wenn es große, einfarbige Flächen besitzt, wie in \ref{} deutlich zu erkennen ist.
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.3]{images/L-lsb-sichtbare-einbettung.png}
		\caption{Auf der linken Seite befinden sich eingebettete Daten, auf der rechten Seite nicht.}
		\label{fig:L: LSB No Padding}
	\end{figure}
	
	
	Die resultierende Datei ist deutlich größer als die Originale. Das liegt daran dass durch das einbetten der Daten große einfarbige Flächen minimal verändert wurden, wodurch sie sich nicht mehr so gut komprimieren lassen wie zuvor.
	
	
	\subsection{Barcode Verfahren}