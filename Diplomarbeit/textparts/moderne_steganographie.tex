\chapter{Moderne Steganographie}
	
	Mit moderner Steganographie sind Verfahren gemeint, welche nur mit Hilfsmittel der elektronischen Datenverarbeitung funktionieren. Sie verlassen sich meist darauf das in riesigen Zahlenmengen kleine Hinweise versteckt sind. Solch große Datenmengen lassen sich per Hand nicht mehr berechnen, wie etwa die vielen Millionen Bildpunkte auf einer digital Fotografie. 
	
	In dem nachfolgendem Kapitel werden einige dieser Verfahren erklärt und etwaige Fehler und Schwierigkeiten die damit verbunden sind aufgezeigt. Außerdem werden einige Implementierungen gezeigt, verglichen und auf die Verwendbarkeit im Alltag getestet. 
	
	\section{Allgemein}
	
	In dem folgenden Abschnitt wird der Begriff Whitening erklärt und auf die Möglichkeit von Fehlerkorrekturmaßnahmen bei der Übertragung von Daten eingegangen.
	
	\subsection{Whitening}
	
	
	Als Whitening werden Prozesse und Techniken bezeichnet mit dem Ziel, Daten jegliche Ordnung und Regelmäßigkeit zu entziehen. Je besser ein Whitening Verfahren funktioniert desto weniger ist der Datenstrom von generierten Zufallswerten unterscheidbar. \\
	
	Dies hat den Vorteil, dass die Daten nach der Transformation in dem einzubettendem Medium nicht so stark auffallen wie zuvor. \\
	
	Whitening Verfahren wandeln auf deterministische Weise Datenströme, welche in etwa wie \ref{fig:L: Whitening Clear} aussehen können, um damit sie dem Profil von \ref{fig:L: Whitening Random} ähneln. Dies muss auf eine Art und Weise geschehen das beim extrahieren der Daten die angewandte Operation wieder rückgängig gemacht werden kann. Es können also keine wirklich zufälligen generierten Daten zum Einsatz kommen. 
	
	Man verwendet hier vor allem sogenannte Pseudozufallsgeneratoren, welche lediglich die Eigenschaften von echten zufälligen Ereignissen nachahmen, bei Bedarf aber beliebig oft wiederholt werden können. Dadurch ist sichergestellt das sich die angewandten Operationen auch wieder rückgängig machen lassen. Es werden auch oft Methoden aus der Kryptologie verwendet, welche nicht nur herausragende Ergebnisse in Hinsicht auf Zufälligkeit erzielen, sondern zugleich auch die Daten mit Hilfe eines Schlüssel schützen.
	 
	
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=1]{images/L-whitening-clear.png}
		\caption{Hier deutlich zu erkennen die verwendeten ASCII Zeichen.}
		\label{fig:L: Whitening Clear}
	\end{figure}

	\begin{figure}[H]
		\centering
		\includegraphics[scale=1]{images/L-whitening-random.png}
		\caption{In diesen zufälligen Daten kann kein Muster erkannt werden.}
		\label{fig:L: Whitening Random}
	\end{figure}
	
	\ltodo{Höhere Auflösung für Whitening Diagramme https://docs.google.com/spreadsheets/d/1xDMWNJa9r2ggmzPAmDgE8qYJ5hk-8Hh9ZFuKrGrx7Gw}
	
	
	
	
     
	
	\subsubsection {Pseudozufallsgenerator mit bitweiser Verknüpfung}
	
	Bei Verfahren welche auf Pseudozufallsgeneratoren bauen ist die größte Stärke auch gleich die größte Schwäche: ''Sie sind vorhersehbar''. Sie Schützen zwar das Steganogramm vor unwissenden Dritten, wie so oft aber nicht wenn jemand gezielt danach sucht. Ihre sehr beschränkte Anzahl an Seeds und die Reproduzierbarkeit führen dazu das ein Angreifer sehr einfach auf die gängigsten Generatoren testen kann. 
	\\
	Das hier zur Anwendung kommende Prinzip ''Security through obscurity'' war bereits zu Beginn des 20. Jahrhunderts bekannt und auch als nicht sicher eingestuft. Das bekannteste Beispiel für Security through obscurity ist einen nicht standardisierten Port für eine Webanwendung zu verwenden. Dies Schützt zwar vor automatisierten Bots, ein gezielter Angriff hebelt diesen ''Sicherheitsmechanismus'' innerhalb von Minuten aus. Genau so ist es mit schwachen Whitening Verfahren welche auf Obskurität setzen.
	\\
	In dem nachfolgenden Beispiel wird als Whitening der Datenstrom mit Hilfe der XOR-Operation mit einem Pseudozufallszahlengeneratoren Datenstrom verknüpft. Zum Einsatz kommt hier ein Kongruenzgenerator wie er auch in der Standard Java Klasse java.lang.Random verwendet wird.  
	
	\begin{figure}[H]
	\begin{tabular}{|l|l|c|c|c|c|c|c|}
		\hline 
		& Byte 1 & Byte 2 & Byte 3 & Byte 4 & Byte 5 & Byte 6 \\ 
		\hline 
		Inhalt  & L & o & r & e & m &   \\ 
		\hline 
		Datenstrom & 76 & 111 & 114 & 101 & 109 & 32 \\ 
		\hline 
		Random (Seed=0) & 187 & 212 & 61 & 155 & 163 & 79 \\ 
		\hline 
		Datenstrom XOR Random & 247 & 187 & 79 & 254 & 206 & 111 \\ 
		\hline 
	\end{tabular} 	
    \caption{Wenn der Inhalt wieder hergestellt werden soll muss nur von unten nach oben alles wieder Rückgängig gemacht werden.}
	\label{fig:L: Whitening Random Tabelle}
\end{figure}
	
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=1]{images/L-whitening-vergleich.png}
		\caption{In diesem Vergleich ist gut zu sehen das nach Anwendung von diesem Verfahren der Datenstrom nicht mehr von zufälligen Werten unterscheidbar ist.}
		\label{fig:L: Whitening Random Vergleich}
	\end{figure}
	
	\subsubsection {AES-256 Verschlüsselung mit Key}
	
	Es kann auch die Eigenschaft von Verschlüsselung genutzt werden, Daten derart zu verarbeiten dass sie nicht mehr von zufälligen Werten unterscheidbar ist. In dem nachfolgenden Beispiel wird die zurzeit als sicher geltende AES-256 Verschlüsselung verwendet. 
	
	Folgende Java Funktion wurde für die Verschlüsselung des Plaintext verwendet:
	\lstinputlisting[firstline=30,lastline=42,caption={AESVerfahren.java},label={fig:L: AES Java}]{sources/AESVerfahren.java}
	
	Wenn man die daraus resultierenden Daten auswertet, lässt sich wieder der gewünschte Whitening-Effekt beobachten. 
	\begin{figure}[H]
		\centering
		\includegraphics[scale=1]{images/L-whitening-aes.png}
		\caption{Vergleich zwischen AES verschlüsselten Daten und zufälligen Werten.}
		\label{fig:L: Whitening AES}
	\end{figure}

	
	\subsection{Fehlerkorrekturverfahren}
	
	Moderne Verfahren sind sehr anfällig auf verlustbehaftete Komprimierung. Dadurch das sie meistens darauf basieren einzelne Bits zu verändern, passiert es auch sehr schnell das die erneute Manipulation des Trägermaterials zum Verlust der versteckten Daten führt. In dem folgenden Abschnitt werden Techniken vorgestellt um diesen Informationsverlust zu verhindern oder wenigstens zu entdecken. Des weiteren werden mehrere Verfahren nach Robustheit verglichen.
	
	\subsubsection{Redundante Datenspeicherung}
	
	Eine Möglichkeit ist es die Daten mehrfach abzuspeichern. Das bietet Schutz vor Manipulation von einzelnen Teilen des Bild. Zum Beispiel das Wegschneiden von Rändern, das Entfernen von Gesichtern, Wasserzeichen oder einfach Bild Über- und Unterschriften welche erst später zu dem Bild hinzugefügt werden.  
	
	Keine Verbesserung der Robustheit findet jedoch bei Komprimierung des Trägermaterial statt, denn hier werden alle Teile geringfügig verändert was bereits ausreicht um einen kompletten Informationsverlust zu verursachen. 
	
	Auch wenn das Trägermaterial vergrößert/verkleinert wird Hilft redundante Speicherung meist nicht. Bei Skalierung von Bildern werden immer Filtering Methoden eingesetzt werden. Diese kombinieren oft mehrere Pixel zu einem einzelnen und wenden dabei zahlreiche Operationen an. Dadurch geht fast immer sämtliche steganographisch versteckte Information verloren. 
	
	\subsubsection{Paritätsbit}
	
	Die Parität einer Zahl beschreibt ob eine Zahl durch zwei Teilbar ist. Das Paritätsbit wird zur Überprüfung auf Übertragungsfehler verwendet indem es nach einer festgelegten Anzahl an übertragenen Bits mitgesendet wird. Es werden die gesetzten Bits des zu überprüfenden Bereich gezählt. Ist dieser Wert nun eine gerade/ungerade Zahl wird das Paritätsbit entsprechend gesetzt.

	Wenn im Laufe der Übertragung ein einzelnes Bit umgedreht wird kann dies durch das Paritätsbit entdeckt werden. Der Fehler selbst kann dadurch aber nicht ausgebessert werden, da nicht bekannt ist wo er in der Bitfolge aufgetreten ist. Außerdem kann nur eine ungerade Anzahl an Fehlern festgestellt werden. Eine Weiterentwicklung diese Verfahren stellt der unten vorgestellte Hamming-Code dar.
	
	\subsubsection{Zyklische Redundanzprüfung (\zb CRC-32)}
	
	Die zyklische Redundanzprüfung basiert auf Polynomdivison. Es wird ein CRC-Polynom gewählt  dessen Koeffizienten entweder 1 oder 0 sind. So entspricht etwa die Bitfolge 110101 dem Polynom $ x^{5} + x^{4} + x^{2} + 1$. 
	Die zu prüfende Bitfolge wird nun mit einem Padding aus $n$ Nullen versehen, wobei $n$ dem Grad es Polynom entspricht. Das Ergebnis wird durch das CRC-Polynom dividiert, der Rest der Division an die Ursprüngliche Bitfolge ohne Padding angehängt und das ganze dann Übertragen. Dabei muss beachtet werden das bei der Division ausschließlich der XOR-Operator verwendet wird.
	Auf der Empfängerseite wird die gesamte übertragene Bitfolge erneut durch das CRC-Polynom dividiert. Beträgt der Rest Null dann ist entweder kein Fehler aufgetreten oder ein sehr unwahrscheinlicher. 
	Mit diesem Verfahren können nicht nur Fehler entdeckt, sondern im besten Fall sogar ausgebessert werden.
	
	

	\section{Modifikation von Bilddateien} 
	
	Bilder auf einem Computer sind nichts anderes als Matrizen welche Farbeinformationen für die einzelnen Pixel des Bildes beinhalten. Es gibt zahlreiche Verfahren in diesen Daten zu verstecken. Im den folgenden Kapitel werden einige dieser Verfahren vorgestellt. Dadurch dass alle Daten im Computer in Binärform als Zahl gespeichert sind, ist es vollkommen egal welche Datei als Payload eingebettet wird. 
	
	Aus diesem Grund wird in den Beispielen die Kodierung aus \ref{L: Kodierung Payload} für die Payload verwendet.
	\begin{table}[]
		\centering
		\caption{Kodierungstabelle der Payload}
		\label{L: Kodierung Payload}
		\begin{tabular}{|lll|lll|lll|lll|}
			\hline
			\textbf{Zeichen} & \textbf{DEC} & \textbf{BIN} & \textbf{Zeichen} & \textbf{DEC} & \textbf{BIN} & \textbf{Zeichen} & \textbf{DEC} & \textbf{BIN} & \textbf{Zeichen} & \textbf{DEC} & \textbf{BIN} \\ \hline
			A                & 0            & 000000        & I                & 8            & 001000        & Q                & 16           & 010000        & Y                & 24           & 011000        \\
			B                & 1            & 000001        & J                & 9            & 001001        & R                & 17           & 010001        & Z                & 25           & 011001        \\
			C                & 2            & 000010        & K                & 10           & 001010        & S                & 18           & 010010        & Leerzeichen      & 26           & 011010        \\
			D                & 3            & 000011        & L                & 11           & 001011        & T                & 19           & 010011        & .                & 27           & 011011        \\
			E                & 4            & 000100        & M                & 12           & 001100        & U                & 20           & 010100        & ,                & 28           & 011100        \\
			F                & 5            & 000101        & N                & 13           & 001101        & V                & 21           & 010101        & ?                & 29           & 011101        \\
			G                & 6            & 000110        & O                & 14           & 001110        & W                & 22           & 010110        & !                & 30           & 011110        \\
			H                & 7            & 000111        & P                & 15           & 001111        & X                & 23           & 010111        & ''               & 31           & 011111        \\
			\hline
		\end{tabular}
	\end{table}
%	\begin{table}[]
%		\centering
%		\caption{Kodierungstabelle der Payload}
%		\label{L: Kodierung Payload}
%		\begin{tabular}{|lll|lll|lll|lll|}
%			\hline
%			\textbf{Zeichen} & \textbf{DEC} & \textbf{BIN} & \textbf{Zeichen} & \textbf{DEC} & \textbf{BIN} & \textbf{Zeichen} & \textbf{DEC} & \textbf{BIN} & \textbf{Zeichen} & \textbf{DEC} & \textbf{BIN} \\ \hline
%			A                & 32            & 100000        & I                & 40           & 101000        & Q                & 48           & 110000        & Y                & 56           & 111000        \\
%			B                & 33            & 100001        & J                & 41           & 101001        & R                & 49           & 110001        & Z                & 57           & 111001        \\
%			C                & 34            & 100010        & K                & 42           & 101010        & S                & 50           & 110010        & Zeilenumbruch    & 58           & 111010        \\
%			D                & 35            & 100011        & L                & 43           & 101011        & T                & 51           & 110011        & >                & 59           & 111011        \\
%			E                & 36            & 100100        & M                & 44           & 101100        & U                & 52           & 110100        & <                & 60           & 111100        \\
%			F                & 37            & 100101        & N                & 45           & 101101        & V                & 53           & 110101        & (                & 61           & 111101        \\
%			G                & 38            & 100110        & O                & 46           & 101110        & W                & 54           & 110110        & )                & 62           & 111110        \\
%			H                & 39            & 100111        & P                & 47           & 101111        & X                & 55           & 110111        & End of Message   & 63           & 111111        \\
%			\hline
%		\end{tabular}
%	\end{table}
	
	
	\subsection{Least Significant Bit Verfahren}
	
	Das Least Significant Bit (LSB) Verfahren nützt die Tatsache aus, dass der Farbraum einer modernen Bilddatei sehr groß ist\footnote{Bei den meisten Formaten 24-Bit, wodurch 16,777,216 Farben dargestellt werden können}. Dadurch ist es für das menschliche Auge sehr schwierig, eng beieinander liegende Farbtöne zu unterscheiden. Computerprogramme können nun gezielt einzelne Farben manipulieren um Informationen in den Pixel des Bildes zu kodieren. 
	
	Bei einem 24-Bit RGB Bild besteht jeder Farbkanal aus 8 Bit. Um die Nachricht zu kodieren wird das LSB von einem oder mehreren der Farbkanäle des Pixel auf den jeweiligen Wert aus der kodierten Nachricht gesetzt. Da das LSB nur einen wertmäßigen Unterschied von +/-1 ausmacht wenn es verändert wird, fällt diese Änderung kaum auf. Wenn wir bei einem Pixel einen der Farbkanäle bearbeiten verändern wir den Farbwert des Kanal um $\frac{1}{256} = 0.39\% $. Der Farbwert des Pixel ändert sich sogar nur um $ \frac{1}{16777216} = 0.00000596\% $. Es ist so gut wie unmöglich mit dem freien Auge hier noch einen Unterschied zu erkennen.
	
	Ein große Rolle spielt wie viel Trägermaterial zur Verfügung steht und wie viele Daten darin eingebettet werden. Je nachdem kann man die einzelnen Bits weiter verteilen oder muss sogar mehrere Bits auf ein Pixel. 
	Es ist auch durchaus sinnvoll diverse Prüfsummen in die eingebetteten Daten einzubauen um sicher zu stellen das die extrahierten Daten auch keine Fehler enthalten. Wenn genug Platz zur Verfügung steht ist es auch möglich die Daten redundant zu speichern.
	
	\ltodo{Tabelle mit Vergleich wie viele Bit Farbe / wie viele Bit Daten und wie viel Prozent das ausmacht + Bildbeispiele für den Farbunterschied den das ausmacht}
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.7]{images/L-lsb-entwurf.png}
		\caption{LSB Verfahren Erklärung}
		\label{fig:L: LSB in Bitmap}
	\end{figure}
	
	In dem Beispiel aus \ref{fig:L: LSB Tabelle} wurde eine Datendichte von einem Zeichen pro Pixel gewählt. Bei einem Bild mit 2  Megapixel lassen sich bis zu 2 Millionen Zeichen abspeichern. Das Buch ''Schöne neue Welt'' von Aldous Huxley hat rund 430.000 Zeichen, geht sich also bereits vier Mal in einem doch recht kleinen Bild aus. Das setzt aber Voraus das die in \ref{L: Kodierung Payload} angeführte Kodierungstabelle verwendet wird. Diese unterstützt aber weder Kleinbuchstaben noch Zeilenumbrüche, Umlaute oder Zahlen. Das Buch wäre durchaus noch lesbar, aber eben doch recht umständlich. In der ASCII Kodierung hat das Buch eine Größe von 449.414 Bytes, also 3.595.312 Bits. Bei einer Datendichte von 6 Bit / Pixel geht sich das Buch dennoch in einem 2 Megapixel großen Bild aus.
	
	\begin{figure}[H]
		\centering
		\begin{tabular}{|c|c|c|c|c|c|c|c|}
			\hline 
			Pixel Nummer & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\ 
			\hline 
			Nachricht & T & R & E & F & F & P & U \\ 
			\hline 
			Dec & 19 & 17 & 4 & 4 & 5 & 15 & 20 \\ 
			\hline 
			Binär & 10011 & 10001 & 00100 & 00100 & 00101 & 01111 & 10100 \\ 
			\hline 
			Roter Farbwert & RRRR RR10 & RRRR RR10 & RRRR RR00 & RRRR RR00 & RRRR RR00 & RRRR RR01 & RRRR RR10 \\ 
			\hline 
			Grüner Farbwert & GGGG GG01 & GGGG GG00 & GGGG GG10 & GGGG GG10 & GGGG GG10 & GGGG GG11 & GGGG GG10 \\ 
			\hline 
			Blauer Farbwert & BBBB BBB1 & BBBB BBB1 & BBBB BBB0 & BBBB BBB0 & BBBB BBB1 & BBBB BBB1 & BBBB BBB0 \\ 
			\hline 
		\end{tabular} 
		\caption{Beispiel für Kodierung von einem Zeichen pro Pixel.}
		\label{fig:L: LSB Tabelle}
	\end{figure}
	
	In dem in \ref{fig:L: LSB Earth} gezeigtem Beispiel wurde das Buch ''Schöne neue Welt'' in ein Bild der Erde integriert. Verwendet wurde das in \ref{fig:L: LSB Java} gezeigte Java-Programm. Die kurze Länge des Programm zeigt das dieses Verfahren sehr einfach zu implementieren ist. Man kann durchaus, egal wo man sich gerade befindet, mit Hilfe eines Computers ein Programm schreiben und geheime Nachrichten versenden. Durch den  zusätzlichen Einsatz von Whitening kann also von überall aus eine steganografisch sichere Datenübermittlung stattfinden, ohne vora. 
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.3]{images/L-schoene-neue-earth.png}
		\caption{In diesem Bild wurde ein ganzes Buch versteckt, und es ist trotzdem nicht zu erkennen.}
		\label{fig:L: LSB Earth}
	\end{figure}

	\lstinputlisting[caption={LSBVerfahren.java},label={fig:L: LSB Java}]{sources/LSBVerfahren.java}

	
	Wenn die einzubettenden Daten nicht den gesamten Verfügbaren ''Speicherplatz'' innerhalb des Steganogramm verwenden, sollte unbedingt ein Padding aus zufälligen Daten hinzugefügt werden. Sonst können sich deutliche Unterschiede in dem Aussehen des Bild ergeben wenn es große, einfarbige Flächen besitzt, wie in \ref{fig:L: LSB No Padding} deutlich zu erkennen ist.
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.3]{images/L-lsb-sichtbare-einbettung.png}
		\caption{Auf der linken Seite befinden sich eingebettete Daten, auf der rechten Seite nicht. Innerhalb des Kreises wurde der Effekt verstärkt dargestellt.}
		\label{fig:L: LSB No Padding}
	\end{figure}
	
	
	Die resultierende Datei ist deutlich größer als die Originale. Das liegt daran dass durch das einbetten der Daten große einfarbige Flächen minimal verändert wurden, wodurch sie sich nicht mehr so gut komprimieren lassen wie zuvor.
	
	
	\subsubsection{Varianten des Least Significant Bit Verfahren}
	
	Das LSB Verfahren gibt in zahlreichen Varianten und Abstufungen. Deswegen ist es durchaus eine Herausforderung automatische Erkennungsverfahren für diese Steganogramme zu entwickeln. Des weiteren kommt es häufig vor dass die eingebetteten Daten verschlüsselt wurden, was eine automatisch Erkennung beinahe unmöglich macht. 
	
	Selbstverständlich kann das LSB Verfahren nicht nur auf verlustfreie Bildformate wie PNG Dateien angewendet werden. Es gibt auch Implementierungen welche Musikdateien oder verlustbehaftete Bildformate wie JPEG als Trägerdatei verwenden. 
	
	Der bekannteste Algorithmus dafür ist JSteg. Bei jedem verlustbehafteten Format gibt es irgendwann einen Teil wo Daten, auch wenn bereits komprimiert, verlustfrei gespeichert werden. Das nützt JSteg aus und wendet dort das LSB Verfahren an. Bei dem JPEG Format geschieht dies wie in \ref{} gezeig nach dem verlustbehafteten Teil des JPEG Algorithmus.  Es wird dabei darauf geachtet dass nur Bits verändert werden welche eine möglichst geringe Auswirkung auf das originale Bild haben. 
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.9]{images/L-jsteg.png}
		\caption{Die Daten werden im verlustfreien Teil des JPEG Algorithmus hinzugefügt.}
		\label{fig:L: LSB No Padding}
	\end{figure}
	%Quelle http://www-i6.informatik.rwth-aachen.de/web/Misc/Coding/365/li/material/notes/Chap4/Chap4.2/Chap4.2.html
	
	% http://cise.ufl.edu/~makumar/proposalppt.pdf
	% http://www.guillermito2.net/stegano/jsteg/
	
	\subsection{Barcode Verfahren}
	
	Das Barcodeverfahren ist ein selbst erfundenes Verfahren welches einen Barcode in einem Bild versteckt. Dies geschieht indem das Bild zuerst in ein 8-Bit Graustufenbild konvertiert und anschließend das Histogramm des Bildes generiert wird. 
	
	Ein Histogram ist eine grafische Abbildung der Anzahl einzelner Farbwerte. In das  \ref{fig:L: Barcode Example}  wurde das Bild zuerst in ein 8-BGraustufenbild umgewandelt, die entstehenden 256 verschiedenen Werte gezählt und grafisch Dargestellt. 
	
	Wenn man nun das Bild gezielt so bearbeitet das bestimmte Farbwerte nicht mehr vorkommen, dann ergeben sich dadurch auch im Histogramm entsprechende Spalten. Mit dieser Hilfe kann nun jedes beliebiges eindimensionale Barcodeformat eingebettet werden.
	
		
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.08]{images/L-earth.png}
		\includegraphics[scale=0.3]{images/L-barcode-example.png}
		\caption{}
		\label{fig:L: Barcode Example}
	\end{figure}
	
	
	Damit gängige Barcodescanner jedoch den Barcode wahrnehmen können muss das Histogramm grafisch gewisse Anforderungen erfüllen. Die meisten vorhandenen Histogramm Generatoren stellen das Resultat in einer schönen ansprechenden Form dar, \zb der Graph geglättet und in Farbe. Barcodescanner brauchen aber schwarze Striche welche deutlich voneinander unterscheidbar sind. Deshalb muss ein spezieller Barcodegenerator verwendet werden.
	
	 Ein Beispiel für einen solchen Generator findet sich in \ref{fig:L: HistogramViewer}. Dieses Programm generiert dann für Barcodescanner verwendbare Histogramme, wie in \ref{fig:L: Barcode Histogram Example} gezeigt wird. In diesem Beispiel wurde das gängige Barcodeformat CODE\_128 verwendet und der Text ''Simon Lehner-D.'' damit kodiert.
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=1.5]{images/L-histogram-viewer-output.png}
		\caption{fig:L: Barcode Histogram Example}
		\label{fig:L: Barcode Histogram Example}
	\end{figure}
	
	\ltodo {Einfach nur den link zum git repo reintun?}
	\lstinputlisting[caption={HistogramViewer.java},label={fig:L: HistogramViewer}]{sources/HistogramViewer.java}
	
	
	
	
	
	
	
	
	
	
	\subsection{Stereoskopische Verfahren}
	
	Die Stereoskopie beschreibt Methoden um auf Bildern den Eindruck zu machen, dass diese drei Dimensional sind, obwohl physikalisch gar keine Tiefe vorhanden ist. Sie macht sich dabei zur Hilfe, dass das Gehirn eigentlich nur zwei 2D Aufnahmen der Umgebung bekommt und diese dann erst als 3D Gebilde interpretiert. 
	
	Um im Gehirn den Eindruck von räumlicher Tiefe zu erzeugen müssen beide Augen die selbe Szene aus zwei verschiedenen Blickwinkel zu sehen bekommen. Dies funktioniert normalerweise dadurch das beide Augen in einem Abstand von ungefähr 15cm voneinander entfernt sind. Wenn nun aber beide Blickwinkel mit einer Kamera aufgenommen und nebeneinander gelegt wurden muss man dem Gehirn etwas nachhelfen. Mit der richtigen Blicktechnik, \zb durch Schielen, können die beiden Teilbilder wieder übereinandergelegt werden und der gewünschte tiefen Effekt tritt auf.
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=1.5]{images/L-stereogram-example.jpg}
		\caption{Beispiel fr ein Stereogramm}
		\label{fig:L: Stereogramm Example}
	\end{figure}
	\ltodo{Quelle raus suchen oder eigenes Bild aufnehmen}
	
	Es gibt verschiedene Techniken um Stereogramme zu erstellen, die sich vor allem durch die Wahl des Trägermaterial unterscheiden
	
	\begin{itemize}
		\item Classic stereogram
		
		Das klassiche Stereogramm aus 2 Bildern, welche mit der richtigen Blicktechnik oder einem Stereoskop dreidimensional gesehen werden können. 
		
		
		\item Single image stereogram (SIS) 
		
		Einzelbildstereogramme, auch oft Autostereogramm genannt, verwenden wie der Name schon sagt nur ein einzelnes Trägerbild um die Formen zu beinhalten. Dazu benötigen sie ein sich wiederhohlendes Muster in welches mit Hilfe eines Programm und einer Depthmap die Formen hinzugefügt werden.
		
		Grundsätzlich kann jede der hier genannten Techniken auch Autostereogramme erzeugen.
		
		\item Random dot stereogram (RDS)
		
		Bei diesem werden Bilder bestehend aus zufälligen Punkten verwendet um dreidimensionale Formen darzustellen. Dadurch ist es oft auf den ersten Blick nicht gleich ersichtlich, dass es sich hier um ein Stereogramm handelt.
		
		\item Text stereogram
		
		Als Trägermaterial wird ausschließlich Text verwendet. Ein Beispiel dafür ist unter \ref{fig:L: Stereogramm Example ASCII} zu sehen.
		
		\item Map textured stereogram 
		
		Diese Technik ist sehr ähnlich wie RDS, nur das hier Texturen wie sie in etwa Videospielen vorkommen verwendet werden. Diese haben die Eigenschaft beliebig oft wiederholt werden zu können, ohne das sich Kanten im Bild ergeben. Dadurch lässt sich sehr gut ein Stereogramm daraus erzeugen.
		
		Die bekannte Buchserie ''Magic Eye'' beinhaltet vor allem solche Stereogramme, weil die Blicktechnik hier einfacher anzuwenden ist als \zb bei Text Stereogrammen.
		
		\item Wallpaper stereogram / object array stereogram
		
		Bei einem Objekt Array Stereogramm wird ein und dasselbe Bild mehrere male wiederholt. Dabei werden aber die Abstände von einzelnen Elementen des Bild unterschiedlich gewählt um den gewünschten 3D Effekt zu erzielen.
		
		
	\end{itemize}
	
	
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=1.0]{images/L-stereogram-ascii.png}
		\caption{Beispiel für ein Text Stereogramm}
		\label{fig:L: Stereogramm Example ASCII}
	\end{figure}
	\ltodo{Quelle: https://web.archive.org/web/20080517013244/archive.museophile.org/3d/ascii-3d.html}
	
	
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.40]{images/L-stereogram-tree.jpg}
		\caption{Beispiel für ein Objekt-Array Stereogramm}
		\label{fig:L: Stereogramm Example Object Array}
	\end{figure}
	\ltodo{Quelle: http://www.pakin.org/~scott/stereograms/}
	
	Aus diesen Techniken ergeben sich nun einige praktische Anwendungsmöglichkeiten, welche im folgenden genauer bearbeitet werden. Des weiteren werden Hilfmittel gezeigt mit deren Hilfe man Stereogramme automatisch entdecken und Entschlüsseln darstellen kann.
	
	
	\subsubsection{Erzeugen von Stereogrammen mithilfe einer Depth Map}
	
	Zuerst benötigt man sowohl ein gutes Muster als Grundlage als auch eine sogenannte Depth Map. Depth-Maps sind im Grunde einfach Schwarz-Weiß Bilder bei denen der Weißwert jedes Pixels die Tiefe/Höhe der jeweiligen Position angibt.
	Beide Teile gibt es zahlreich im Internet. Bei Bedarf können Depth Maps auch mit einer geeigneten 3D-Grafiksuite wie etwa Blender erzeugt werden. Aber auch einfache Bildbearbeitungsprogramme sind gut dazu geeignet vor allem Text als Depth Map abzuspeichern.
	
	Dabei gilt vor allem der Grundsatz: Je einfacher das dargestellte Objekt in der Depth Map, desto einfacher ist es auch das Stereogramm ohne technischer Hilfsmittel dreidimensional sehen zu können.
	
	
	Um das Stereogramm nun zu erzeugen wird ein neues leeres Bild erzeugt mit der selben größe wie die Depth Map. Auf diesem Bild wird nun das gewählte Muster auf dem linken Rand hineinkopiert, so dass es von oben bis unten einen Streifen mit dem Muster bildet. Die Größe dieses Grundstreifen wird von nun an $N$ genannt gibt an um wie viel die Augen das Bild verschieben müssen um auf der Grundtiefe zu sein. 
	
	Die restlichen noch leeren Teile des Bildes werden nun erzeugt indem immer das Pixel auf der selben Höhe um $N$ nach links verschoben kopiert wird. Um den gewünschten Tiefeneffekt zu bekommen wird noch jeweils ein Offset hinzugefügt das dem Wert der aktuellen Position auf der Depth Map entspricht.
	
	
	$$
	E(x,y)=
	\begin{cases}
	M(x,y), & \text{if } x < N \\
	E(x - N + (s * D(x,y)), & \text{else}
	\end{cases}
	$$

	\begin{itemize}
		\item \textbf{$E(x,y)$} das resultierende Stereogramm
		\item \textbf{$M(x,y)$} das Muster welches als Grundlage verwendet werden soll.
		\item \textbf{$D(x,y)$} die Depth Map $[0.0;1.0]$
		\item \textbf{$s$} ein Faktor der Angibt wie groß der Tiefeneffekt sein soll $[0.0;N]$
	\end{itemize}

	\begin{figure}[H]
		\centering
		\includegraphics[scale=1]{images/L-stereogram-anleitung.png}
		\caption{Die Pixel werden je nach Depth Map vom linken Strich + Offset zu dem rechten Kopiert.}
		\label{fig:L: Stereogramm Anleitung}
	\end{figure}

	Wiederholt man diesen Vorgang über das gesamte Bild ergibt sich dann folgendes Stereogramm.
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.4]{images/L-stereogram-selber.png}
		\caption{Kaum zu erkennen sind die versteckten Formen.}
		\label{fig:L: Stereogramm Anleitung}
	\end{figure}
	
	Verwendet wurde dafür dieses Java-Programm:
	\lstinputlisting[caption={StereogrammGenerator.java},label={fig:L: Stereogramm Generator in  Java}]{sources/StereogrammGenerator.java}
	
	
	
	\subsubsection{Steganographie mithilfe von Stereogrammen}
	
	Ein Autostereogramm ist eigentlich schon ein Steganogramm, da ja der eigentliche Inhalt auf den ersten Blick nicht ersichtlich ist. Wenn man ein Schwarz/Weiß Bild mit Text drauf als Depth Map verwendet ergibt das ein Stereogramm welches einen geheimen Text enthält. 
	
	
	\subsubsection{Grafisches Hilfsmittel zum Entschlüsseln von Stereogrammen}
	
	Wenn man nun keine Motivation oder nicht genügend Zeit hat die richtige Blicktechnik zu erlernen kann man auf technische Hilfsmittel zurückgreifen.
	
	Meistens reicht es aus einfach das Bild in einem geeigneten Bildbarbeitungsprogramm zu öffnen und dort richtig zu bearbeiten: Es muss das gesamte Bild kopiert und wieder eingefügt werden. Das eingefügte Bild wird dann auf der selben Höhe solange nach links und rechts verschoben bis man den gewünschten Effekt erzielt. Dabei ist zu beachten, dass das Programm die Composite-Einstellungen ''Differenz'' unterstützt und diese auch verwendet wird. Das Wort Composite kommt aus dem Englischen und bedeutet so viel wie Zusammensetzung oder Gemisch. Im Sinne von Bildbearbeitung ist damit gemeint auf welche Art und Weiße die Pixel miteinander verbunden werden sollen. Für Stereogramme müssen die Pixel voneinander subtrahiert werden, es wird also die Differenz der Pixel benötigt. Daher auch die entsprechende Einstellung. 
	
	Wenn der Bedarf da ist, des öfteren Stereogramme zu Entschlüsseln, dann ist es oft Hilfreich ein kleines Programm dafür zu verwenden. Es gibt zum Beispiel eine Implementierung eines solchen Programm unter \url{http://magiceye.ecksdee.co.uk/}. Diese verwendet jedoch Low-Level Javascript Array Operationen, wodurch die Anwendung bei sehr großen Dateien zu langsam und damit unbrauchbar ist.
	
	 Moderne Browser unterstützen für die Rendering Kontexte in Javascript die oben erwähnten Composite-Operationen. Daher kann eine eigene kleine Funktion als Solver in nicht mehr als 5 Lines of Code geschrieben werden. Diese verwendet Hardwarebeschleunigung und ist somit selbst bei riesigen Dateien noch ausreichend schnell. Diese Funktion muss nur noch in eine kleine Oberfläche verpackt werden und ist schon einsatzbereit.
	 
	 \lstinputlisting[caption={Einfacher Stereogramm Solver},label={fig:L: Stereogramm Solver}]{sources/StereogrammSolverShort.js}
	 \ltodo{Javascript wird nicht unterstuetzt}
	 
	 
	 \ltodo{Stereogramme mit verlaufenden 3D Bildern sind etwas komplizierter zum schoen darstellen, muss ich nur implementieren, hab da schon ne idee}
	
	\subsubsection{Automatische Erkennung von Stereogrammen}
	
	Es gibt noch kein Standardverfahren zur Erkennung ob es sich bei einem Bild um ein Stereogramm handelt. Deswegen wurde im Rahmen des Projekt Geocaching-Tools und für diese Diplomarbeit ein  eigenes entwickelt. 
	
	Wie bereits bei den grafischen Hilfsmittel zum Entschlüsseln von Stereogrammen gezeigt werden Stereogramme beim Verarbeiten eine Kopie des Bildes um ein gewisses Offset nach rechts verschoben und anschließend vom Bild subtrahiert. Die Herausforderung und das Ziel des Verfahren ist es also das richtige Offset, falls vorhanden, zu erkennen. 
	
	Dabei werden ganz Ähnlich wie man es bei dem grafischen Hilfsmittel per Hand machen kann alle möglichen Verschiebungen generiert. Zwei identische Farben voneinander Subtrahiert ergeben die Farbe schwarz. Es wird also nach einem Offset gesucht bei dem ein Möglichst großer Teil des Bildes Schwarz wird. Damit ist auch schon der größte Teil der Arbeit getan. Aus den prozentualen Schwarzanteilen vom Gesamtbild über die verschiedenen Verschiebungen ergibt sich für jedes Bild eine Datenserie. Diese muss nur noch Analysiert werden. 
	
	In \ref{fig:L: Stereogramm Erkennung Vergleich} sind vier Bilder mit dieser Technik analysiert worden. Dabei kann man gut erkennen dass sich ein Spike in der Datenreihe ergibt wenn das Bild ein Stereogramm ist. Das größte Problem bei der Sache sind Bilder welche im vor hinein bereits größten Teil aus schwarz bestehen. Auch Signaturen von Bildern welche nur sehr wenige Farben beinhalten sind oft den Signaturen von Stereogrammen sehr ähnlich. Ein Beispiel dafür sind Bilder mit viel weißem Text auf schwarzem Hintergrund.
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.5]{images/L-stereogram-erkennung-vergleich.png}
		\caption{Bei dem Stereogramm kann ein Spike in der Datenreihe erkannt werden}
		\label{fig:L: Stereogramm Erkennung Vergleich}
	\end{figure}

	Stereogramme haben mit dieser Analyse immer einen Spike in der Datenreihe während normale Bilder einen eindeutigen Abwärtstrend haben. Lediglich Texte sind schwer zu unterscheiden und einzuordnen. Eine Möglichkeit wäre nun eine künstliche Intelligenz darauf zu trainieren, diese Datenreihen zu analysieren. Die hier generierten Daten eignen sich sehr gut für ein solches Verfahren weil sie Aufgrund der prozentuellen Angaben eine fixe Größe besitzen. Dafür wird jedoch sehr viel Rechenleistung benötigt, wodurch hier eine effizientere Methode gewählt wurde.
	
	Gesucht wird die größte Steigung zweier Punkte. Also $ d(j) - d(i) , i > j $ soll maximiert werden. Dazu wurde folgender sehr einfacher und schneller Algorithmus gewählt:
	
	\lstinputlisting[caption={Steigung},label={fig:L: Steigung Java}]{sources/Steigung.java}
	
	Das Problem was sich hier jedoch ergibt ist, dass wie in \ref{fig:L: Stereogramm Erkennung Vergleich} zu sehen ist, Texte eine recht hohes Ergebnis bei diesem Test erzielen, da sie einen steigenden Trend besitzen. Dies Ergibt sich aus dem hohen Schwarzanteil des Originalbild. Dadurch das bei der Berechnung auch der sich nicht mit dem verschobenen Bild überschneidende Teil miteinbezogen wird, führt das zu diesen sehr hohen Werten. 
	
	Wenn bei dem Algorithmus nur der Teil zur Berechnung herangezogen von dem das verschobenen Bild 
	subtrahiert wurde verändern sich die Datenreihen deutlich: Die Spikes bei Stereogrammen vergrößern sich um ein vielfaches und der generelle Trend wird flacher. 
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.5]{images/L-stereogram-erkennung-vergleich-besser.png}
		\caption{Die verbesserte Variante erzielt deutlichere Ergebnisse}
		\label{fig:L: Stereogramm Erkennung Vergleich Verbessert}
	\end{figure}

	Es ist aber auch zu beobachten das im letzten Viertel die Werte sehr stark zu schwanken anfangen. Das liegt daran dass der beobachtete Bereich immer kleiner wird und dadurch sehr wenige kleine Überschneidungen einen sehr großen Effekt auf das Ergebnis haben. Um noch bessere Ergebnisse zu erzielen kann also das letzte Viertel der Datenreihe vernachlässigt werden, da es bei einem Offset von mehr als 75\% sehr unwahrscheinlich ist das es sich hier noch um ein Stereogramm handelt.
	
	In der folgenden Grafik werden die drei Versionen miteinander Verglichen.
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.8]{images/L-stereogram-erkennung-vergleich-ergebnisse.png}
		\caption{Ein Wert von mehr als 25\% heißt, dass es sich Wahrscheinlich um ein Stereogramm handelt.}
		\label{fig:L: Stereogramm Erkennung Vergleich Verbessert}
	\end{figure}
	
	
	Wie zu sehen ist erzielt das eben vorgestellte Verfahren bei vier von fünf Testfällen ein korrektes Ergebnis. Um eine 100\% korrekte Aussage treffen zu können werden kompliziertere Verfahren benötigt, wie die oben vorgeschlagene Verwendung von künstlicher Intelligenz.
	
	
	\subsubsection{Bildfehler erkennen}
	
	Jeder kennt diese Suche den Fehler Bilder aus Tageszeitungen. Diese bestehen aus zwei beinahe identischen Bildern. Bei einem der beiden wurden jedoch einzelne Details entfernt. Das ist ähnlich wie bei herkömmlichen Stereogrammen, bei denen die einzelne Teile zwar nicht entfernt, sondern verschoben sind.
	
	
	Dadurch das diese beiden Anwendungen so ähnlich sind, kann man sehr gut Hilfsmittel aus der Stereographie anwenden um die Bildfehlerspiele zu lösen. Wenn man die Blicktechniken von Stereogrammen auf diese Spiele anwendet, überlappen die beiden Bilder derart, dass auf der selben Stelle der entfernte Teil sichtbar und unsichtbar ist. Deshalb weiß das Gehirn nicht welches der beiden Augen recht hat, weil das linke Auge zum Beispiel eine Schornstein sieht und das Rechte nicht. Diese Teile des Bildes schauen dann aus als würden sie Flimmern.
	
	Wenn ein automatisches Hilfsmittel auf ein derartiges Bildpaar angewendet wird, dann ergibt sich bei dem richtigen Offset ein schwarzes Bild auf dem nur die Fehler als Farbhaufen zu sehen sind. Im Sinne der Steganographie kann zum Beispiel der Sekundenteil einer Koordinate als Position auf einem Quadratischen Bild mit je 1000px Seitenlänge markiert werden, indem dort der Bildfehler platziert wird.
	
	\ltodo{Finde ein Beispiel für ein solches Suchbildrätsel und löse es mit GC-Tools}
	
	
	
	
	\subsection{Odd-Pixel Verfahren}
	
	Das Wort ''Odd'' kommt aus dem Englischen und bedeutet seltsam oder merkwürdig. Es handelt sich also um merkwürdige Pixel. Damit ist zum Beispiel gemeint wenn in einem fast komplett dunklen Bild irgendwo ein einzelnes Pixel Weiß, Grasgrün oder Rubinrot ist. So ein seltsames Pixel fällt einem sofort auf: Das passt da einfach nicht rein. 
	
	Man kann sich das zu Nutze machen indem man dem Odd-Pixel eine ganz bestimme Position oder eine spezielle Farbe gibt. Ein Beispiel: Ein grünes Odd-Pixel bedeutet ja und ein rotes nein oder die Position gibt die Koordinaten für einen Treffpunkt an. 
	
	Wenn man ein solches Odd-Pixel verstecken will muss man aber beachten dass die Wahrnehmungsschwelle eines Menschen nicht unterschritten wird. Sonst führt das unweigerlich dazu, dass niemand das Steganogramm entziffern kann. Jedoch ist es kaum beeinflussbar für wen das Pixel sichtbar ist, wessen Wahrnehmungsschwelle also ausreicht. 
	
	Eine große Herausforderung stellt hier vor allem die automatische Erkennung eines solchen Odd-Pixel dar. Weiß man wonach man sucht macht es die ganze Sache schon einfacher. Wird zum Beispiel ein komplett weißes Pixel gesucht, also mit den allen Werten der RGB-Skala auf 255, so muss das Programm nur eben dieses Pixel aufspüren. Es ist also das beste ein Programm zur Verfügung zu stellen welches diese Aufgabe zwar nicht von alleine lösen kann, jedoch einem Menschen bei der Arbeit unterstützt.
	
	Um das einfache Arbeiten zu ermöglichen sind folgende Funktionen nützlich:
	\begin{itemize}
		\item Eine Zoomfunktion
		\item Markieren von Stellen mit einem Stift/Radierer Werkzeug
		\item Filtern nach bestimmten Farben. Ähnlich dem Füllwerkzeug bei Bildbearbeitungsprogrammen, nur als einstellbarer Filter welcher Bereiche verdunkelt welche nicht dem Kriterium entsprechen.
		\item Automatisches Markieren von gefundenen Stellen. Einzelne Pixel sind sehr schwer zu sehen, selbst wenn diese eingefärbt wurden. Eine Art bunte Umrandung ist dabei sehr hilfreich. 
		\item Gruppieren von benachbarten Pixeln. Diese Pixelgruppen dann in einer auswählbaren Liste darstellen um Position, Farbe und weitere Eigenschaften abrufen zu können.
	\end{itemize}
	
	Mithilfe diesen Funktionen sollte es nicht mehr allzu schwer sein Odd-Pixel zu finden.
	
	Erwähnenswert ist hier eine einfache Technik mit deren Hilfe einzelne Pixel sowie Pixelgruppen umrandet werden können. Es handelt sich um einen Filter und zwei Pinsel Operationen welche nacheinander auf die Auswahlmaske angewendet werden. 
	
	Ein Pinsel wird auf das ganze Bild angewendet indem für jeden Punkt auf dem Bild überprüft wird ob eine bestimmte Bedingung eintrifft und wenn ja wird ein Kreis in der angegebenen Größe mit einer bestimmten Farbe dort hin gezeichnet.
	
	Ein Filter bestehen aus einem sogenannten Kernel, ein zwei dimensionales Zahlenarray. Wie in \ref{fig:L: Odd Pixel Conv} dargestellt wird jeder Wert aus dem Kernel auf den Input mit einer festgelegten Operation verknüpft und die Ergebnisse summiert. Wenn nicht genauer definiert ist die verwendete Operation die Multiplikation. Zahlreiche bekannten Filter und Effekte aus Bildbearbeitungsprogrammen können auf diese Weise implementiert werden. 
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.5]{images/L-odd-pixel-conv.png}
		\caption{Kernel wird auf den Input angewendet um den Output zu erzeugen.}
		\label{fig:L: Odd Pixel Conv}
	\end{figure}
	
	
	Einige Anwendungsbeispiele für Kernel sind:
	\begin{itemize}
		\item Laplacian Kantenerkennungs Kernel \\
		$
		K =\begin{bmatrix}
			-1 & -1 & -1 \\
			-1 & 8  & -1 \\
			-1 & -1 & -1
		\end{bmatrix}
		$		
		$
		K = \begin{bmatrix}
		0 &  1 & 0 \\
		1 & -4 & 1 \\
		0 &  1 & 0
		\end{bmatrix}
		$		
		$
		K_{H} = \begin{bmatrix}
		0  & 0 &  0 \\
		-1 & 2 & -1 \\
		0  & 0 &  0
		\end{bmatrix}
		$			
		$
		K_{V} = \begin{bmatrix}
		0 & -1 & 0 \\
		0 &  2 & 0 \\
		0 & -1 & 0
		\end{bmatrix}
		$				
		
		\item Gaußscher Weichzeichner Kernel\\
		$
		G = \frac{1}{16} \begin{bmatrix}
		1 & 2 & 1 \\
		2 & 4 & 2 \\
		1 & 2 & 1
		\end{bmatrix}
		$			
		
		\item Sobel Operator Kernel\\
		$ 
		S_{H}=\begin{bmatrix}
		1 & 2 & 1 \\
		0 & 0 & 0 \\
		-1 & -2 & -1
		\end{bmatrix} 
		$
		$
		S_{V}=\begin{bmatrix}
		1 & 0 & -1 \\
		2 & 0 & -2 \\
		1 & 0 & -1
		\end{bmatrix}
		$			
		
		\item Emboss Kernel \\
		$
		E =\begin{bmatrix}
		-2 & -1 & 0 \\
		-1 &  1 & 1 \\
		 0 &  1 & 2
		\end{bmatrix}
		$
		
	\end{itemize}
	
	
	% Quelle http://colah.github.io/posts/2014-07-Understanding-Convolutions/
	% http://matlabtricks.com/post-5/3x3-convolution-kernels-with-online-demo#demo
	
	Java stellt in seiner Standardbibliothek die beiden Klassen Namens ConvolveOp und Kernel zur Verfügung. Diese benötigen nur ein Double Array mit den Kernel Werten und können dann auf Objekte der Klasse BufferedImage angewendet werden.
	
	Um nun Details in einem Bild zu markieren wird zuerst ein Pinsel Operator angewendet welcher jeden Punkt der die Bedingung erfüllt mit einem großen Pinsel übermalt. Auf das Resultat wird dann ein Kantenerkennungsfilter angewendet. Dann wird erneut ein Pinsel verwendet, jedoch ein kleinerer. Die Größe des ersten Pinsel gibt an in welchem Abstand die Komponenten umrandet werden sollen. Die Größe des zweiten Pinsel gibt an wie dick der Rand sein soll.
	
	In \ref{fig:L: Mask} sind die einzelnen Schritte des Verfahren dargestellt.
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.7]{images/L-mask.png}
		\caption{Selbst kleine Details sind groß Umrandet und gut Sichtbar}
		\label{fig:L: Mask}
	\end{figure}
	
	\lstinputlisting{sources/ConvolveOpCircleItExample.java}
	
	
	
	
	